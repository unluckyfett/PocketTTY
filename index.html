<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pocket Teletype</title>
  <style>
    body { font-family: sans-serif; background: #111; color: #ddd; text-align: center; }
    canvas { background: #000; margin: auto; display: block; }
    input, button, textarea { margin: 0.5em; padding: 0.5em; font-size: 1em; }
    #txText { width: 90%; height: 80px; }
  </style>
</head>
<body>

<h2>Pocket Teletype - AFSK Baudot Terminal</h2>

<!-- TX Section -->
<textarea id="txText" placeholder="Enter text to transmit..."></textarea><br>
<label>Mark Freq: <input id="markFreqInput" value="2125" type="number" step="1"></label>
<label>Space Freq: <input id="spaceFreqInput" value="2295" type="number" step="1"></label>
<label>Baud Rate: <input id="baudRateInput" value="45.45" type="number" step="0.01"></label><br>
<button onclick="startTransmit()">Transmit</button>

<!-- RX Section -->
<div style="text-align:center;">
  <canvas id="micScope" width="600" height="100"></canvas>
  <button id="toggleReceiveBtn" onclick="toggleReceive()">Start Receive</button>
  <div id="status" style="margin-top: 0.5em; font-size: 1em; color: lime; height: 1.5em;"></div>
  <label>Sensitivity Threshold:
    <input type="number" id="thresholdRatioInput" value="2.0" step="0.1" style="width: 60px;">
  </label>
  <div style="margin-top: 0.5em;">
    <span id="ledMark" style="display:inline-block;width:20px;height:20px;border-radius:50%;background:#333;margin:0 10px;"></span> Mark
    <span id="ledSpace" style="display:inline-block;width:20px;height:20px;border-radius:50%;background:#333;margin:0 10px;"></span> Space
  </div>
</div>
<pre id="rxOutput"></pre>

<script>
let audioCtx = null;
let processor = null;
let source = null;
let receiving = false;
let ledTimeout = null;
let txCtx = null;

function toggleReceive() {
  if (!receiving) {
    startReceive();
    document.getElementById('toggleReceiveBtn').innerText = 'Stop Receive';
    document.getElementById('status').innerText = 'Receiving...';
  } else {
    stopReceive();
    document.getElementById('toggleReceiveBtn').innerText = 'Start Receive';
    document.getElementById('status').innerText = '';
  }
  receiving = !receiving;
}

function startReceive() {
  const markFreq = parseFloat(document.getElementById('markFreqInput').value);
  const spaceFreq = parseFloat(document.getElementById('spaceFreqInput').value);
  const baud = parseFloat(document.getElementById('baudRateInput').value);
  const thresholdRatio = parseFloat(document.getElementById('thresholdRatioInput').value);
  const sampleRate = 44100;
  const samplesPerBit = Math.floor(sampleRate / baud);

  navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    source = audioCtx.createMediaStreamSource(stream);
    processor = audioCtx.createScriptProcessor(1024, 1, 1);
    const goertzelMark = new Goertzel(markFreq, sampleRate);
    const goertzelSpace = new Goertzel(spaceFreq, sampleRate);

    let bitBuffer = [];
    let bitTimer = 0;

    const canvas = document.getElementById('micScope');
    const ctx = canvas.getContext('2d');
    const scopeWidth = canvas.width;
    const scopeHeight = canvas.height;

    const ledMark = document.getElementById('ledMark');
    const ledSpace = document.getElementById('ledSpace');

    processor.onaudioprocess = e => {
      const samples = e.inputBuffer.getChannelData(0);
      const energyMark = goertzelMark.run(samples);
      const energySpace = goertzelSpace.run(samples);

      let markActive = energyMark > energySpace * thresholdRatio;
      let spaceActive = energySpace > energyMark * thresholdRatio;

      ledMark.style.background = markActive ? 'lime' : '#333';
      ledSpace.style.background = spaceActive ? 'red' : '#333';

      if (ledTimeout) clearTimeout(ledTimeout);
      ledTimeout = setTimeout(() => {
        ledMark.style.background = '#333';
        ledSpace.style.background = '#333';
      }, 100);

      let bit = null;
      if (markActive) bit = 1;
      else if (spaceActive) bit = 0;

      if (bit !== null) {
        bitTimer++;
        if (bitTimer >= (samplesPerBit / 1024)) {
          bitTimer = 0;
          bitBuffer.push(bit);
          if (bitBuffer.length === 8) {
            decodeBaudot(bitBuffer);
            bitBuffer = [];
          }
        }
      }

      ctx.clearRect(0, 0, scopeWidth, scopeHeight);
      ctx.beginPath();
      ctx.strokeStyle = 'lime';
      for (let i = 0; i < scopeWidth; i++) {
        const idx = Math.floor(i * samples.length / scopeWidth);
        const y = (0.5 - samples[idx] / 2) * scopeHeight;
        ctx.lineTo(i, y);
      }
      ctx.stroke();
    };

    source.connect(processor);
    processor.connect(audioCtx.destination);
  });
}

function stopReceive() {
  if (processor) processor.disconnect();
  if (source) source.disconnect();
  if (audioCtx) audioCtx.close();
  processor = null;
  source = null;
  audioCtx = null;
  document.getElementById('ledMark').style.background = '#333';
  document.getElementById('ledSpace').style.background = '#333';
  if (ledTimeout) clearTimeout(ledTimeout);
}

function startTransmit() {
  const markFreq = parseFloat(document.getElementById('markFreqInput').value);
  const spaceFreq = parseFloat(document.getElementById('spaceFreqInput').value);
  const baud = parseFloat(document.getElementById('baudRateInput').value);
  const text = document.getElementById('txText').value.toUpperCase();

  const LETTERS = {
    '': 0, 'E': 1, '
': 2, 'A': 3, ' ': 4, 'S': 5, 'I': 6, 'U': 7,
    '
': 8, 'D': 9, 'R': 10, 'J': 11, 'N': 12, 'F': 13, 'C': 14, 'K': 15,
    'T': 16, 'Z': 17, 'L': 18, 'W': 19, 'H': 20, 'Y': 21, 'P': 22, 'Q': 23,
    'O': 24, 'B': 25, 'G': 26, 'M': 28, 'X': 29, 'V': 30
  };

  const FIGURES = {
    '': 0, '3': 1, '
': 2, '-': 3, ' ': 4, '\'': 5, '8': 6, '7': 7,
    '
': 8, '$': 9, '4': 10, ',': 12, '!': 13, ':': 14, '(': 15,
    '5': 16, '"': 17, ')': 18, '2': 19, '#': 20, '6': 21, '0': 22, '1': 23,
    '9': 24, '?': 25, '&': 26, '.': 28, '/': 29, ';': 30
  };

  const LTRS = 0x1F; // 11111
  const FIGS = 0x1B; // 11011
  let shift = 'LTRS';
  const bits = [];

  for (let ch of text) {
    let code;
    let targetShift = null;
    if (LETTERS.hasOwnProperty(ch)) {
      code = LETTERS[ch];
      targetShift = 'LTRS';
    } else if (FIGURES.hasOwnProperty(ch)) {
      code = FIGURES[ch];
      targetShift = 'FIGS';
    } else {
      continue; // skip unsupported
    }

    if (targetShift !== shift) {
      shift = targetShift;
      const shiftCode = (shift === 'LTRS') ? LTRS : FIGS;
      bits.push(0);
      for (let i = 0; i < 5; i++) bits.push((shiftCode >> i) & 1);
      bits.push(1, 1);
    }

    bits.push(0);
    for (let i = 0; i < 5; i++) bits.push((code >> i) & 1);
    bits.push(1, 1);
  }

  if (!txCtx) txCtx = new (window.AudioContext || window.webkitAudioContext)();
  const oscillator = txCtx.createOscillator();
  const gain = txCtx.createGain();
  oscillator.connect(gain);
  gain.connect(txCtx.destination);

  let t = txCtx.currentTime;
  const dt = 1 / baud;
  for (let b of bits) {
    oscillator.frequency.setValueAtTime(b ? markFreq : spaceFreq, t);
    t += dt;
  }
  oscillator.start();
  oscillator.stop(t);
}

  let t = txCtx.currentTime;
  const dt = 1 / baud;
  for (let b of bits) {
    oscillator.frequency.setValueAtTime(b ? markFreq : spaceFreq, t);
    t += dt;
  }
  oscillator.start();
  oscillator.stop(t);
}

class Goertzel {
  constructor(freq, sampleRate) {
    this.N = 1024;
    this.k = Math.round(0.5 + ((this.N * freq) / sampleRate));
    this.omega = (2 * Math.PI * this.k) / this.N;
    this.coeff = 2 * Math.cos(this.omega);
    this.s_prev = 0;
    this.s_prev2 = 0;
  }
  run(samples) {
    this.s_prev = this.s_prev2 = 0;
    for (let i = 0; i < samples.length; i++) {
      let s = samples[i] + this.coeff * this.s_prev - this.s_prev2;
      this.s_prev2 = this.s_prev;
      this.s_prev = s;
    }
    return this.s_prev2 ** 2 + this.s_prev ** 2 - this.coeff * this.s_prev * this.s_prev2;
  }
}

function decodeBaudot(bits) {
  const LETTERS = [
    '', 'E', '
', 'A', ' ', 'S', 'I', 'U',
    '
', 'D', 'R', 'J', 'N', 'F', 'C', 'K',
    'T', 'Z', 'L', 'W', 'H', 'Y', 'P', 'Q',
    'O', 'B', 'G', '', 'M', 'X', 'V'
  ];

  const FIGURES = [
    '', '3', '
', '-', ' ', '\'', '8', '7',
    '
', '$', '4', '\'', ',', '!', ':', '(',
    '5', '"', ')', '2', '#', '6', '0', '1',
    '9', '?', '&', '', '.', '/', ';'
  ];

  const LTRS = 0x1F;  // 11111
  const FIGS = 0x1B;  // 11011

  const value = bits.slice(1, 6).reduce((acc, b, i) => acc | (b << i), 0);

  if (typeof decodeBaudot.shift === 'undefined') decodeBaudot.shift = 'LTRS';

  if (value === LTRS) {
    decodeBaudot.shift = 'LTRS';
    return;
  } else if (value === FIGS) {
    decodeBaudot.shift = 'FIGS';
    return;
  }

  const table = decodeBaudot.shift === 'FIGS' ? FIGURES : LETTERS;
  let char = table[value] || '?';
  document.getElementById("rxOutput").textContent += char;
}
</script>
</body>
</html>
