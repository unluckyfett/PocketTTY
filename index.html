<!-- UPDATED HTML: Hybrid decoder based on ITTY DSP concepts integrated -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pocket Teletype</title>
  <style>
    body { font-family: sans-serif; background: #111; color: #ddd; text-align: center; }
    canvas { background: #000; margin: auto; display: block; }
    input, button, textarea { margin: 0.5em; padding: 0.5em; font-size: 1em; }
    #txText { width: 90%; height: 80px; }
  </style>
</head>
<body>
<h2>Pocket Teletype - AFSK Baudot Terminal</h2>
<textarea id="txText" placeholder="Enter text to transmit..."></textarea><br>
<label>Mark Freq: <input id="markFreqInput" value="2125" type="number"></label>
<label>Space Freq: <input id="spaceFreqInput" value="2295" type="number"></label>
<label>Baud Rate: <input id="baudRateInput" value="45.45" type="number"></label><br>
<button onclick="startTransmit()">Transmit</button>
<div>
  <canvas id="micScope" width="600" height="100"></canvas>
  <button onclick="toggleReceive()" id="toggleReceiveBtn">Start Receive</button>
  <div id="status" style="color: lime; margin: 0.5em;"></div>
  <label>Sensitivity: <input type="number" id="thresholdRatioInput" value="2.0" step="0.1"></label>
  <div style="margin-top: 0.5em;">
    <span id="ledMark" style="width:20px;height:20px;border-radius:50%;background:#333;display:inline-block;margin:0 10px;"></span>Mark
    <span id="ledSpace" style="width:20px;height:20px;border-radius:50%;background:#333;display:inline-block;margin:0 10px;"></span>Space
  </div>
</div>
<pre id="rxOutput"></pre>
<script>
let audioCtx, processor, source, sampleBuffer = [];
let collecting = false, bitBuffer = [], lastSampleTime = 0, baudInterval = 0;
let decodeState = 'IDLE';
const MIN_THRESHOLD = 0.05;

function toggleReceive() {
  if (audioCtx) {
    stopReceive();
    document.getElementById('toggleReceiveBtn').innerText = 'Start Receive';
    document.getElementById('status').innerText = '';
  } else {
    startReceive();
    document.getElementById('toggleReceiveBtn').innerText = 'Stop Receive';
    document.getElementById('status').innerText = 'Receiving...';
  }
}

function startReceive() {
  const markFreq = parseFloat(document.getElementById('markFreqInput').value);
  const spaceFreq = parseFloat(document.getElementById('spaceFreqInput').value);
  const baud = parseFloat(document.getElementById('baudRateInput').value);
  const thresholdRatio = parseFloat(document.getElementById('thresholdRatioInput').value);
  const sampleRate = 44100;
  baudInterval = 1 / baud;

  navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    source = audioCtx.createMediaStreamSource(stream);
    processor = audioCtx.createScriptProcessor(256, 1, 1);

    const markDetector = new Goertzel(markFreq, sampleRate);
    const spaceDetector = new Goertzel(spaceFreq, sampleRate);
    const scopeCanvas = document.getElementById("micScope");
    const scopeCtx = scopeCanvas.getContext("2d");

    processor.onaudioprocess = e => {
      const samples = e.inputBuffer.getChannelData(0);
      for (let i = 0; i < samples.length; i++) sampleBuffer.push(samples[i]);

      const energyMark = markDetector.run(samples);
      const energySpace = spaceDetector.run(samples);
      const signalPower = Math.max(energyMark, energySpace);

      const markLed = document.getElementById("ledMark");
      const spaceLed = document.getElementById("ledSpace");
      markLed.style.background = energyMark > energySpace ? 'lime' : '#333';
      spaceLed.style.background = energySpace > energyMark ? 'red' : '#333';

      // Decode every baud interval using windowed signal power
      const now = audioCtx.currentTime;
      if (now - lastSampleTime >= baudInterval) {
        lastSampleTime = now;
        if (signalPower > MIN_THRESHOLD) {
          const bit = energyMark > energySpace * thresholdRatio ? 1 : 0;
          if (decodeState === 'IDLE' && bit === 0) {
            decodeState = 'START';
            bitBuffer = [0];
          } else if (decodeState === 'START') {
            bitBuffer.push(bit);
            if (bitBuffer.length === 8) {
              decodeState = 'IDLE';
              decodeBaudot(bitBuffer);
            }
          }
        }
      }

      // Draw waveform
      scopeCtx.clearRect(0, 0, scopeCanvas.width, scopeCanvas.height);
      scopeCtx.beginPath();
      scopeCtx.strokeStyle = 'lime';
      for (let i = 0; i < scopeCanvas.width; i++) {
        const idx = Math.floor(i * samples.length / scopeCanvas.width);
        const y = (0.5 - samples[idx] / 2) * scopeCanvas.height;
        scopeCtx.lineTo(i, y);
      }
      scopeCtx.stroke();
    };
    source.connect(processor);
    processor.connect(audioCtx.destination);
  });
}

function stopReceive() {
  if (processor) processor.disconnect();
  if (source) source.disconnect();
  if (audioCtx) audioCtx.close();
  audioCtx = processor = source = null;
  document.getElementById('ledMark').style.background = '#333';
  document.getElementById('ledSpace').style.background = '#333';
}

function decodeBaudot(bits) {
  const LTRS = 0x1F, FIGS = 0x1B;
  const LETTERS = ['', 'E', '\n', 'A', ' ', 'S', 'I', 'U', '\r', 'D', 'R', 'J', 'N', 'F', 'C', 'K',
                   'T', 'Z', 'L', 'W', 'H', 'Y', 'P', 'Q', 'O', 'B', 'G', '', 'M', 'X', 'V'];
  const FIGURES = ['', '3', '\n', '-', ' ', '\'', '8', '7', '\r', '$', '4', '\'', ',', '!', ':', '(',
                   '5', '"', ')', '2', '#', '6', '0', '1', '9', '?', '&', '', '.', '/', ';'];
  const value = bits.slice(1, 6).reduce((acc, b, i) => acc | (b << i), 0);
  if (typeof decodeBaudot.shift === 'undefined') decodeBaudot.shift = 'LTRS';
  if (value === LTRS) { decodeBaudot.shift = 'LTRS'; return; }
  if (value === FIGS) { decodeBaudot.shift = 'FIGS'; return; }
  const table = decodeBaudot.shift === 'FIGS' ? FIGURES : LETTERS;
  document.getElementById("rxOutput").textContent += table[value] || '?';
}

class Goertzel {
  constructor(freq, sampleRate) {
    this.N = 256;
    this.k = Math.round(this.N * freq / sampleRate);
    this.omega = 2 * Math.PI * this.k / this.N;
    this.coeff = 2 * Math.cos(this.omega);
  }
  run(samples) {
    let s_prev = 0, s_prev2 = 0;
    for (let i = 0; i < samples.length; i++) {
      let s = samples[i] + this.coeff * s_prev - s_prev2;
      s_prev2 = s_prev;
      s_prev = s;
    }
    return s_prev2 ** 2 + s_prev ** 2 - this.coeff * s_prev * s_prev2;
  }
}
</script>
</body>
</html>
